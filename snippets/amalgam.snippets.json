{
    "(system": {
        "prefix": "(system",
        "body": [
            "(system"
        ],
        "description": "system string command || Executes system command specified by command.  See system commands in later table."
    },
    "(get_defaults": {
        "prefix": "(get_defaults",
        "body": [
            "(get_defaults"
        ],
        "description": "get_defaults string value_type || Retrieves the default values of the named field, either \"mutation_opcodes\" or \"mutation_types\""
    },
    "(parse": {
        "prefix": "(parse",
        "body": [
            "(parse"
        ],
        "description": "parse string str || String is parsed into code, and the result is returned."
    },
    "(unparse": {
        "prefix": "(unparse",
        "body": [
            "(unparse"
        ],
        "description": "unparse code c [bool pretty_print] [bool sort_keys] || Code is unparsed and the representative string is returned. If the pretty-print boolean is passed as true, output will be in pretty-print format, otherwise by default it will be inlined.  If sort_keys is true, then in will print assoc structures and anything that could come in different orders in a natural sorted order by key, otherwise it will default to whatever order it is stored in memory."
    },
    "(if": {
        "prefix": "(if",
        "body": [
            "(if"
        ],
        "description": "if [bool condition1] [code then1] [bool condition2] [code then2] ... [bool conditionN] [code thenN] [code else] || If the condition1 bool is true, then it will evaluate to the then1 argument.  Otherwise condition2 will be checked, repeating for every pair.  If there is an odd number of parameters, the last is the final 'else', and will be evaluated as that if all conditions are false."
    },
    "(seq": {
        "prefix": "(seq",
        "body": [
            "(seq"
        ],
        "description": "seq [code c1] [code c2] ... [code cN] || Runs each code block sequentially. Evaluates to the result of the last code block run, unless it encounters a conclude in an earlier step, in which case it will halt processing and evaluate to the value returned by conclude. Note that the last step will not consume a concluded value."
    },
    "(parallel": {
        "prefix": "(parallel",
        "body": [
            "(parallel"
        ],
        "description": "parallel [code c1] [code c2] ... [code cN] || Runs each code block, possibly in any order. Evaluates to null"
    },
    "(lambda": {
        "prefix": "(lambda",
        "body": [
            "(lambda"
        ],
        "description": "lambda * function [bool evaluate_and_wrap] || Evaluates to the code specified without evaluating it.  Useful for referencing functions or handling data without evaluating it.  The parameter evaluate_and_wrap defaults to false, but if it is true, it will evaluate the function, but then return the result wrapped in a lambda opcode."
    },
    "(conclude": {
        "prefix": "(conclude",
        "body": [
            "(conclude"
        ],
        "description": "conclude * conclusion || Evaluates to the conclusion wrapped in a conclude opcode.  If a step in a seq, let, declare, or while evaluates to a conclude (excluding variable declarations for let and declare, the last step in set, let, and declare, or the condition of while), then it will conclude the execution and evaluate to the value conclusion.  Note that conclude opcodes may be nested to break out of outer opcodes"
    },
    "(call": {
        "prefix": "(call",
        "body": [
            "(call"
        ],
        "description": "call * function assoc arguments || Evaluates the code after pushing the arguments assoc onto the scope stack."
    },
    "(call_sandboxed": {
        "prefix": "(call_sandboxed",
        "body": [
            "(call_sandboxed"
        ],
        "description": "call_sandboxed * function assoc arguments [number operation_limit] [number max_node_allocations] || Evaluates the code specified by *, isolating it from everything except for arguments, which is used as a single layer of the scope stack.  This is useful when evaluating code passed by other entities that may or may not be trusted.  Opcodes run from within call_sandboxed that require any form of permissions will not perform any action and will evaluate to null.  If operation_limit is specified, it represents the number of operations that are allowed to be performed. If operation_limit is 0 or infinite, then an infinite of operations will be allotted, up to the limits of the current calling context. If max_node_allocations is specified, it represents the maximum number of nodes that are allowed to be allocated, limiting the total memory, up to the current calling context's limit.   If max_node_allocations is 0 or infinite and the caller also has no limit, then there is no limit to the number of nodes to be allotted as long as the machine has sufficient memory.  Note that if max_node_allocations is specified while call_sandboxed is being called in a multithreaded environment, if the collective memory from all the related threads exceeds the average memory specified by call_sandboxed, that may trigger a memory limit for the call_sandboxed."
    },
    "(while": {
        "prefix": "(while",
        "body": [
            "(while"
        ],
        "description": "while bool condition [code code1] [code code2] ... [code codeN] || Each time the condition evaluates to true, it runs each of the code trees sequentially, looping. Evaluates to the last codeN or null if the condition was initially false or if it encounters a conclude, it will halt processing and evaluate to the value returned by conclude.  For iteration of the loop, pushes a new target scope onto the target stack, with current_index being the iteration count, and previous_result being the last evaluated codeN of the previous loop."
    },
    "(let": {
        "prefix": "(let",
        "body": [
            "(let"
        ],
        "description": "let assoc data [code function1] [code function2] ... [code functionN] || Pushes the key-value pairs of data onto the scope stack so that they become the new variables, then runs each code block sequentially, evaluating to the last code block run, unless it encounters a conclude, in which case it will halt processing and evaluate to the value returned by conclude.  Note that the last step will not consume a concluded value."
    },
    "(declare": {
        "prefix": "(declare",
        "body": [
            "(declare"
        ],
        "description": "declare assoc data [code function1] [code function2] ... [code functionN] || For each key-value pair of data, if not already in the current context in the scope stack, it will define them.  Then runs each code block sequentially, evaluating to the last code block run, unless it encounters a conclude, in which case it will halt processing and evaluate to the value returned by conclude.  Note that the last step will not consume a concluded value."
    },
    "(assign": {
        "prefix": "(assign",
        "body": [
            "(assign"
        ],
        "description": "assign assoc data|string variable_name [number index1|string index1|list walk_path1|* new_value1] [* new_value1] [number index2|string index2|list walk_path2] [* new_value2] ... || If the assoc data is specified, then for each key-value pair of data, assigns the value to the variable represented by the key found by tracing upward on the stack. If none found, it will create a variable on the top of the stack. If the string variable_name is specified, then it will find the variable by tracing up the stack and then use each pair of walk_path and new_value to assign new_value to that part of the variable's structure.  If there are only two parameters, then it will assign the second parameter to the variable represented by the first."
    },
    "(accum": {
        "prefix": "(accum",
        "body": [
            "(accum"
        ],
        "description": "accum assoc data|string variable_name [number index1|string index1|list walk_path1] [* accum_value1] [number index2|string index2|list walk_path2] [* accum_value2] ... || If the assoc data is specified, then for each key-value pair of data, assigns the value of the pair accumulated with the current value of the variable represented by the key on the stack, and stores the sum in the variable.  It searches for the variable name tracing up the stack to find the variable. If none found, it will create a variable on the top of the stack. Accumulation is performed differently based on the type: for numeric values it adds, for strings, it concatenates, for lists it appends, and for assocs it appends based on the pair. If the string variable_name is specified, then it will find the variable by tracing up the stack and then use each pair of walk_path and new_value to accum accum_value to that part of the variable's structure.  If there are only two parameters, then it will accum the second parameter to the variable represented by the first."
    },
    "(retrieve": {
        "prefix": "(retrieve",
        "body": [
            "(retrieve"
        ],
        "description": "retrieve [string variable_name|list variable_names|assoc indexset] || If string specified, gets the value on the stack specified by the string. If list specified, returns a list of the values on the stack specified by each element of the list interpreted as a string. If assoc specified, returns an assoc with the indices of the assoc which was passed in with the values being the appropriate values on the stack for each index."
    },
    "(+": {
        "prefix": "(+",
        "body": [
            "(+"
        ],
        "description": "+ [number x1] [number x2] ... [number xN] || Sums all numbers."
    },
    "(-": {
        "prefix": "(-",
        "body": [
            "(-"
        ],
        "description": "- [number x1] [number x2] ... [number xN] || Evaluates to x1 - x2 - ... - xN. If only one parameter is passed, then it is treated as negative"
    },
    "(*": {
        "prefix": "(*",
        "body": [
            "(*"
        ],
        "description": "* [number x1] [number x2] ... [number xN] || Evaluates to the product of all numbers."
    },
    "(/": {
        "prefix": "(/",
        "body": [
            "(/"
        ],
        "description": "/ [number x1] [number x2] ... [number xN] || Evaluates to x1 / x2 / ... / xN."
    },
    "(mod": {
        "prefix": "(mod",
        "body": [
            "(mod"
        ],
        "description": "mod [number x1] [number x2] ... [number xN] || Evaluates the modulus of x1 % x2 % ... % xN."
    },
    "(get_digits": {
        "prefix": "(get_digits",
        "body": [
            "(get_digits"
        ],
        "description": "get_digits number value [number base] [number start_digit] [number end_digit] [bool relative_to_zero] || Evaluates to a list of the number of each digit of value for the given base.  If base is omitted, 10 is the default.  The parameters start_digit and end_digit can be used to get a specific set of digits, but can also be infinite or null to catch all the digits on one side of the number.  The interpretation of start_digit and end_digit are with respect to relative_to_zero, which defaults to true.  If relative_to_zero is true, then the digits are indexed from their distance to zero, such as \"5 4 3 2 1 0 . -1 -2\".  If relative_to_zero is false, then the digits are indexed from their most significant digit, such as \"0 1 2 3 4 5 . 6  7\".  The default values of start_digit and end_digit are the most and least significant digits respectively."
    },
    "(set_digits": {
        "prefix": "(set_digits",
        "body": [
            "(set_digits"
        ],
        "description": "set_digits number value [number base] [list of number or null digits] [number start_digit] [number end_digit] [bool relative_to_zero] || Evaluates to a number having each of the values in the list of digits replace each of the relative digits in value for the given base.  If a digit is null in digits, then that digit is not set.  If base is omitted, 10 is the default.  The parameters start_digit and end_digit can be used to get a specific set of digits, but can also be infinite or null to catch all the digits on one side of the number.  The interpretation of start_digit and end_digit are with respect to relative_to_zero, which defaults to true.  If relative_to_zero is true, then the digits are indexed from their distance to zero, such as \"5 4 3 2 1 0 . -1 -2\".  If relative_to_zero is false, then the digits are indexed from their most significant digit, such as \"0 1 2 3 4 5 . 6  7\".  The default values of start_digit and end_digit are the most and least significant digits respectively."
    },
    "(floor": {
        "prefix": "(floor",
        "body": [
            "(floor"
        ],
        "description": "floor number x || Evaluates to the mathematical floor of x."
    },
    "(ceil": {
        "prefix": "(ceil",
        "body": [
            "(ceil"
        ],
        "description": "ceil number x || Evaluates to the mathematical ceiling of x."
    },
    "(round": {
        "prefix": "(round",
        "body": [
            "(round"
        ],
        "description": "round number x [number significant_digits] [number significant_digits_after_decimal] || Rounds the value x and evaluates to the new value.  If only one parameter is specified, it rounds to the nearest integer.  If significant_digits is specified, then it rounds to the specified number of significant digits.  If significant_digits_after_decimal is specified, then it ensures that x will be rounded at least to the number of decimal points past the integer as specified, and takes priority over the significant_digits."
    },
    "(exp": {
        "prefix": "(exp",
        "body": [
            "(exp"
        ],
        "description": "exp number x || e^x"
    },
    "(log": {
        "prefix": "(log",
        "body": [
            "(log"
        ],
        "description": "log number x [number base] || Log of x.  If a base is specified, uses that base, otherwise defaults to natural log."
    },
    "(sin": {
        "prefix": "(sin",
        "body": [
            "(sin"
        ],
        "description": "sin number theta || sine"
    },
    "(cos": {
        "prefix": "(cos",
        "body": [
            "(cos"
        ],
        "description": "cos number theta || cosine"
    },
    "(acos": {
        "prefix": "(acos",
        "body": [
            "(acos"
        ],
        "description": "acos number theta || inverse cosine"
    },
    "(tan": {
        "prefix": "(tan",
        "body": [
            "(tan"
        ],
        "description": "tan number theta || tangent"
    },
    "(atan": {
        "prefix": "(atan",
        "body": [
            "(atan"
        ],
        "description": "atan number theta [number divisor] || Inverse tangent.  If two numbers are provided, then it evaluates atan theta/divisor."
    },
    "(sinh": {
        "prefix": "(sinh",
        "body": [
            "(sinh"
        ],
        "description": "sinh number theta || hyperbolic sine"
    },
    "(asinh": {
        "prefix": "(asinh",
        "body": [
            "(asinh"
        ],
        "description": "asinh number theta || area hyperbolic sine"
    },
    "(cosh": {
        "prefix": "(cosh",
        "body": [
            "(cosh"
        ],
        "description": "cosh number theta || hyperbolic cosine"
    },
    "(acosh": {
        "prefix": "(acosh",
        "body": [
            "(acosh"
        ],
        "description": "acosh number theta || area hyperbolic cosine"
    },
    "(tanh": {
        "prefix": "(tanh",
        "body": [
            "(tanh"
        ],
        "description": "tanh number theta || hyperbolic tangent"
    },
    "(atanh": {
        "prefix": "(atanh",
        "body": [
            "(atanh"
        ],
        "description": "atanh number theta || area hyperbolic tanh"
    },
    "(erf": {
        "prefix": "(erf",
        "body": [
            "(erf"
        ],
        "description": "erf number errno || error function"
    },
    "(tgamma": {
        "prefix": "(tgamma",
        "body": [
            "(tgamma"
        ],
        "description": "tgamma number z || true (complete) gamma function"
    },
    "(lgamma": {
        "prefix": "(lgamma",
        "body": [
            "(lgamma"
        ],
        "description": "lgamma number z || log-gamma function"
    },
    "(sqrt": {
        "prefix": "(sqrt",
        "body": [
            "(sqrt"
        ],
        "description": "sqrt number x || Returns the square root of x."
    },
    "(pow": {
        "prefix": "(pow",
        "body": [
            "(pow"
        ],
        "description": "pow number base number exponent || Returns the base raised to the exponent"
    },
    "(abs": {
        "prefix": "(abs",
        "body": [
            "(abs"
        ],
        "description": "abs number x || absolute value of x"
    },
    "(max": {
        "prefix": "(max",
        "body": [
            "(max"
        ],
        "description": "max [number x1] [number x2] ... [number xN] || maximum of all of the numbers"
    },
    "(min": {
        "prefix": "(min",
        "body": [
            "(min"
        ],
        "description": "min [number x1] [number x2] ... [number xN] || minimum of all of the numbers"
    },
    "(dot_product": {
        "prefix": "(dot_product",
        "body": [
            "(dot_product"
        ],
        "description": "dot_product list|assoc x1 list|assoc x2 || Evaluates to the sum of all element-wise products of x1 and x2."
    },
    "(generalized_distance": {
        "prefix": "(generalized_distance",
        "body": [
            "(generalized_distance"
        ],
        "description": "generalized_distance list|assoc|number weights list|assoc distance_types list|assoc attributes list|assoc|number deviations number p_value list|assoc|* vector1 [list|assoc|* vector2] [list value_names] || Computes the generalized norm between vector1 and vector2 (or an equivalent zero vector if unspecified) with parameter specified by the p_value (2 being Euclidian distance), using the numerical distance or edit distance as appropriate.  The parameter value_names, if specified as a list of the names of the values, will transform via unzipping any assoc into a list for the respective parameter in the order of the value_names, or if a number will use the number repeatedly for every element.  weights is a list of dimension weights to use for the query, each value mapping to its respective element in the vectors.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  \nFor attributes, the particular distance_types specifies what particular attributes are expected.  In all cases, there is the option to specify a list of values, where the second last value is the difference to use when one of the values being compared is null, and the last value is the difference to use when both of the values are null.  If the last value is omitted, it will use the second last value for both.  If both of the null values are omitted, then it will compute the maximum difference and use that for both.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values given.  Cyclic requires a single value, which is the upper bound of the difference for the cycle range (e.g., if the value is 360, then the supremum difference between two values will be 360, leading 1 and 359 to have a difference of 2).\n  Deviations is a list of numbers that are used during distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0.  If any vector value is null or evaluates to nan, or any of the differences between vector1 and vector2 evaluate to null or nan, then it will compute a corresponding maximum distance value based on the properties of the feature."
    },
    "(entropy": {
        "prefix": "(entropy",
        "body": [
            "(entropy"
        ],
        "description": "entropy list|assoc|number p [list|assoc|number q] [number p_exponent] [number q_exponent] || Computes a form of entropy on the specified vectors using nats (natural log, not bits) in the form of -sum p_i ln (p_i^pexponent * q_i^q_exponent).  For both p and q, if p or q is a list of numbers, then it will treat each entry as being the probability of that element.  If it is an associative array, then elements with matching keys will be matched.  If p or q a number then it will use that value in place of each element.  If p or q is null or not specified, it will be calculated as the reciprocol of the size of the other element (p_i would be 1/|q| or q_i would be 1/|p|).  If either p_exponent or q_exponent is 0, then that exponent will be ignored.  Shannon entropy can be computed by ignoring the q parameters, setting p_exponent to 1 and q_exponent to 0. KL-divergence can be computed by providing both p and q and setting p_exponent to -1 and q_exponent to 1.  Cross-entorpy can be computed by setting p_exponent to 0 and q_exponent to 1."
    },
    "(first": {
        "prefix": "(first",
        "body": [
            "(first"
        ],
        "description": "first [list|assoc|number|string data] || Evaluates to the first element.  If data is a list, it will be the first element.  If data is an assoc, it will evaluate to the first element by assoc storage, but order does not matter. If data is a string, it will be the first character. If data is a number, it will evaluate to 1 if nonzero, 0 if zero."
    },
    "(tail": {
        "prefix": "(tail",
        "body": [
            "(tail"
        ],
        "description": "tail [list|assoc|number|string data] [number retain_count] || Evaluates to everything but the first element.  If data is a list, it will be a list of all but the first element.  If data is an assoc, it will evaluate to the assoc without the first element by assoc storage order, but order does not matter. If data is a string, it will be all but the first character. If data is a number, it will evaluate to the value minus 1 if nonzero, 0 if zero. If a retain_count is specified, it will be the number of elements to retain.  A positive number means from the end, a negative number means from the beginning.  The default value is -1 (all but the first)."
    },
    "(last": {
        "prefix": "(last",
        "body": [
            "(last"
        ],
        "description": "last [list|assoc|number|string data] || Evaluates to the last element.  If it is a list, it will be the last element.  If assoc, it will evaluate to the first element by assoc storage, because order does not matter. If it is a string, it will be the last character. If it is a number, it will evaluate to 1 if nonzero, 0 if zero."
    },
    "(trunc": {
        "prefix": "(trunc",
        "body": [
            "(trunc"
        ],
        "description": "trunc [list|assoc|number|string data] [number retain_count] || Truncates, evaluates to everything but the last element. If data is a list, it will be a list of all but the last element.  If data is an assoc, it will evaluate to the assoc without the first element by assoc storage order, because order does not matter. If data is a string, it will be all but the last character. If data is a number, it will evaluate to the value minus 1 if nonzero, 0 if zero. If truncate_count is specified, it will be the number of elements to retain.  A positive number means from the beginning, a negative number means from the end.  The default value is -1 (all but the last)."
    },
    "(append": {
        "prefix": "(append",
        "body": [
            "(append"
        ],
        "description": "append [list|assoc|* collection1] [list|assoc|* collection2] ... [list|assoc|* collectionN] || Evaluates to a new list or assoc which merges all lists (collection1 through collectionN) based on parameter order. If any assoc is passed in, then returns an assoc (lists will be automatically converted to an assoc with the indices as keys and the list elements as values). If a non-list and non-assoc is specified, then it just adds that one element to the list"
    },
    "(size": {
        "prefix": "(size",
        "body": [
            "(size"
        ],
        "description": "size [list|assoc|string collection] collection || Evaluates to the size of the collection in number of elements.  If collection is a string, returns the length in UTF-8 characters."
    },
    "(range": {
        "prefix": "(range",
        "body": [
            "(range"
        ],
        "description": "range [* function] number low_endpoint number high_endpoint [number step_size] || Evaluates to a list with the range from low_endpoint to high_endpoint.  The default step_size is 1.  Evaluates to an empty list if the range is not valid.  If four arguments are specified, then the function will be evaluated for each value in the range."
    },
    "(rewrite": {
        "prefix": "(rewrite",
        "body": [
            "(rewrite"
        ],
        "description": "rewrite * function * target || Rewrites target by applying the function in a bottom-up manner.  For each node in the target tree, pushes a new target scope onto the target stack, with current_value being the current node and current_index being to the index to the current node relative to the node passed into rewrite accessed via target, and evaluates function.  Returns the resulting tree, after have been rewritten by function."
    },
    "(map": {
        "prefix": "(map",
        "body": [
            "(map"
        ],
        "description": "map * function [list|assoc collection1] [list|assoc collection2] ... [list|assoc collectionN] || For each element in the collection, pushes a new target scope onto the stack, so that current_value accesses the element or elements in the list and current_index accesses the list or assoc index, with target representing the outer set of lists or assocs, and evaluates the function.  Returns the list of results, mapping the list via the specified function. If multiple lists or assocs are specified, then it pulls from each list or assoc simultaneously (null if overrun or index does not exist) and (current_value) contains an array of the values in parameter order.  Note that concurrency is only available when one collection is specified."
    },
    "(filter": {
        "prefix": "(filter",
        "body": [
            "(filter"
        ],
        "description": "filter [* function] list|assoc collection || For each element in the collection, pushes a new target scope onto the stack, so that current_value accesses the element in the list and current_index accesses the list or assoc index, with target representing the original list or assoc, and evaluates the function.  If function evaluates to true, then the element is put in a new list or assoc (matching the input type) that is returned.  If function is omitted, then it will remove any elements in the collection that are null, .nan, or .nas string."
    },
    "(weave": {
        "prefix": "(weave",
        "body": [
            "(weave"
        ],
        "description": "weave [* function] list|immediate values1 [list|immediate values2] [list|immediate values3]... || Interleaves the values lists optionally by applying a function.  If only values1 is passed in, then it evaluates to values1. If values1 and values2 are passed in, or, if more values are passed in but function is null, it interleaves the two lists out to whichever list is longer, filling in the remainder with null, and if any value is an immediate, then it will repeat the immediate value.  If the function is specified and not nulll, it pushes a new target scope onto the stack, so that current_value accesses a list of elements to be woven together from the list, and current_index accesses the list or assoc index, with target representing the original list or assoc.  The function should evaluate to a list, and weave will evaluate to a concatenated list of all of the lists that the function evaluated to."
    },
    "(reduce": {
        "prefix": "(reduce",
        "body": [
            "(reduce"
        ],
        "description": "reduce * function list|assoc collection || For each element in the collection after the first one, it evaluates function with a new target scope on the stack where current_value accesses each of the elements from the collection, current_index accesses the list or assoc index, target accesses the original list or assoc, and previous_result accesses the previously reduced result. If the collection is empty, null is returned. if the collection is of size one, the single element is returned."
    },
    "(apply": {
        "prefix": "(apply",
        "body": [
            "(apply"
        ],
        "description": "apply * to_apply [list|assoc collection] || Creates a new list of the values of the elements of the collection, applies the type specified by to_apply, which is either the type corresponding to a string or the type of to_apply, and then evaluates it. If to_apply has any parameters, these are prepended to the collection as the first parameters. When no extra parameters are passed, it is roughly equivalent to (call (set_type list \"+\"))."
    },
    "(reverse": {
        "prefix": "(reverse",
        "body": [
            "(reverse"
        ],
        "description": "reverse list l || Returns a new list containing the list with its elements in reversed order."
    },
    "(sort": {
        "prefix": "(sort",
        "body": [
            "(sort"
        ],
        "description": "sort [* function] list l || Returns a new list containing the list with its elements sorted in increasing order.  Numerical values come before strings, and code will be evaluated as the representative strings.  If function is specified, it pushes a pair of new target scope onto the stack, so that current_value accesses a list of elements to from the list, and current_index accesses the list or assoc index if it is not already reduced, with target representing the original list or assoc, and evaluates function. The function should return a number, positive if \"(current_value)\" is greater, negative if \"(current_value 1)\" is greater, 0 if equal."
    },
    "(indices": {
        "prefix": "(indices",
        "body": [
            "(indices"
        ],
        "description": "indices list|assoc a || Evaluates to the list of strings or numbers that comprise the indices or indexes for the list or associative list.  It is guaranteed that the opcodes indices and values (assuming the parameter only_unique_values is not true) will evaluate and return elements in the same order when given the same node."
    },
    "(values": {
        "prefix": "(values",
        "body": [
            "(values"
        ],
        "description": "values list|assoc a [bool only_unique_values] || Evaluates to the list of entities that comprise the values for the list or associative list. For a list, it evaluates to itself.  If only_unique_values is true (defaults to false), then it will filter out any duplicate values and only return those that are unique (preserving order of first appearance).  If only_unique_values is not true, then it is guaranteed that the opcodes indices and values will evaluate and return elements in the same order when given the same node."
    },
    "(contains_index": {
        "prefix": "(contains_index",
        "body": [
            "(contains_index"
        ],
        "description": "contains_index list|assoc a string|number|list index || Evaluates to true if the index is in the list or associative list.  If index is a string, it will attempt to look at a as an assoc, if number, it will look at a as a list.  If index is a list, it will traverse a via the elements in the list."
    },
    "(contains_value": {
        "prefix": "(contains_value",
        "body": [
            "(contains_value"
        ],
        "description": "contains_value list|assoc|string a string|number value || Evaluates to true if the value is a value in the list or associative list.  If a is a string, then it uses value as a regular expression and evaluates to true if the regular expression matches."
    },
    "(remove": {
        "prefix": "(remove",
        "body": [
            "(remove"
        ],
        "description": "remove list|assoc a number|string|list index || Removes the index-value pair with index being the index in assoc or index of the list or assoc, returning a new list or assoc with that index removed.  If index is a list of numbers or strings, then it will remove each of the requested indices.  Negative numbered indices will count back from the end of a list."
    },
    "(keep": {
        "prefix": "(keep",
        "body": [
            "(keep"
        ],
        "description": "keep list|assoc a number|string|list index || Keeps only the index-value pair with index being the index in assoc or index of the list or assoc, returning a new list or assoc with that only that index.  If index is a list of numbers or strings, then it will only keep each of the requested indices.  Negative numbered indices will count back from the end of a list."
    },
    "(associate": {
        "prefix": "(associate",
        "body": [
            "(associate"
        ],
        "description": "associate [* index1] [* value1] [* index2] [* value2] ... [* indexN] [* valueN] || Evaluates to the assoc, where each pair of parameters (e.g., index1 and value1) comprises a index/value pair. Pushes a new target scope such that (target), (current_index), and (current_value) access the assoc, the current index, and the current value."
    },
    "(zip": {
        "prefix": "(zip",
        "body": [
            "(zip"
        ],
        "description": "zip [* function] list indices [* values] || Evaluates to a new assoc where the indices are the keys and the values are the values, with corresponding positions in the list matched. If the values is omitted, then it will use nulls for each of the values.  If values is not a list, then all of the values in the assoc returned are set to the same value.  When one parameter is specified, it is the list of indices.  When two parameters are specified, it is the indices and values.  When three values are specified, it is the function, indices and values.  Values defaults to (null) and function defaults to (lambda (current_value)).  When there is a collision of indices, the function is called, it pushes a pair of new target scope onto the stack, so that current_value accesses a list of elements from the list, current_index accesses the list or assoc index if it is not already reduced, with target representing the original list or assoc, evaluates function if one exists, and (current_value) is the new value attempted to be inserted over (current_value 1)."
    },
    "(unzip": {
        "prefix": "(unzip",
        "body": [
            "(unzip"
        ],
        "description": "unzip [list|assoc values] list indices || Evaluates to a new list, using the indices list to look up each value from the values list or assoc, in the same order as each index is specified in indices."
    },
    "(get": {
        "prefix": "(get",
        "body": [
            "(get"
        ],
        "description": "get * data [number index|string index|list walk_path_1] [number index|string index|list walk_path_2] ... || Evaluates to data as traversed by the set of values specified by the second parameter, which can be any of: a number, representing an index, with negative numbers representing backward traversal from the end of the list; a string, representing the index; or a list, representing a way to walk into the structure as the aforementioned values.  If multiple walk paths are specified, then get returns a list, where each element in the list is the respective element retrieved by the respective walk path. If the walk path continues past the data structure, it will return a (null)."
    },
    "(set": {
        "prefix": "(set",
        "body": [
            "(set"
        ],
        "description": "set * data [number index1|string index1|list walk_path1] [* new_value1] [number index2|string index2|list walk_path2] [* new_value2] ... || Performs a deep copy on data (a copy of all data structures referenced by it and its references), then looks at the remaining parameters as pairs.  For each pair, the first is any of: a number, representing an index, with negative numbers representing backward traversal from the end of the list; a string, representing the index; or a list, representing a way to walk into the structure as the aforementioned values. new_value1 to new_valueN represent a value that will be used to replace  whatever is in the location the preceeding location parameter specifies. If a particular location does not exist, it will be created assuming the most generic type that will support the index (as a null, list, or assoc); however, it will not change the type of immediate values to an assoc or list. Note that the target operation will evaluate to the new copy of data, which is the base of the newly constructed data; this is useful for creating circular references."
    },
    "(replace": {
        "prefix": "(replace",
        "body": [
            "(replace"
        ],
        "description": "replace * data [number index1|string index1|list walk_path1] [* function1] [number index2|string index2|list walk_path2] [* function2] ... || Performs a deep copy on data (a copy of all data structures referenced by it and its references), then looks at the remaining parameters as pairs.  For each pair, the first is any of: a number, representing an index, with negative numbers representing backward traversal from the end of the list; a string, representing the index; or a list, representing a way to walk into the structure as the aforementioned values. function1 to functionN represent a function that will be used to replace in place of whatever is in the location, and will be passed the current node in (current_value).  The function does not need to be a function and can just be a constant (which it will be evaluated as).  If a particular location does not exist, it will be created assuming the most generic type that will support the index (as a null, list, or assoc). Note that the target operation will evaluate to the new copy of data, which is the base of the newly constructed data; this is useful for creating circular references."
    },
    "(target": {
        "prefix": "(target",
        "body": [
            "(target"
        ],
        "description": "target [number stack_distance] || Evaluates to the current node that is being iterated over, or the base code of a set or replace that is being created.  If a number is specified, it climbs back up the target stack that many levels.  Useful for seralizing graph data structures or looking up data during iteration."
    },
    "(current_index": {
        "prefix": "(current_index",
        "body": [
            "(current_index"
        ],
        "description": "current_index [number stack_distance] || Like target, but evaluates to the index of the current node being iterated on within target."
    },
    "(current_value": {
        "prefix": "(current_value",
        "body": [
            "(current_value"
        ],
        "description": "current_value [number stack_distance] || Like target, but evaluates to the current node being iterated on within target."
    },
    "(previous_result": {
        "prefix": "(previous_result",
        "body": [
            "(previous_result"
        ],
        "description": "previous_result [number stack_distance] || Like target, but evaluates to the resulting node of the previous iteration for applicable opcodes."
    },
    "(stack": {
        "prefix": "(stack",
        "body": [
            "(stack"
        ],
        "description": "stack || Evaluates to the current execution context, also known as the scope stack."
    },
    "(args": {
        "prefix": "(args",
        "body": [
            "(args"
        ],
        "description": "args [number stack_distance] || Evaluates to the top context of the stack, the current execution context, or scope stack, known as the arguments. If number is specified, then it evaluates to the context that many layers up the stack."
    },
    "(and": {
        "prefix": "(and",
        "body": [
            "(and"
        ],
        "description": "and [bool condition1] [bool condition2] ... [bool conditionN] || If all condition expressions are true, evaluates to conditionN. Otherwise evaluates to false."
    },
    "(or": {
        "prefix": "(or",
        "body": [
            "(or"
        ],
        "description": "or [bool condition1] [bool condition2] ... [bool conditionN] || If all condition expressions are false, evaluates to false. Otherwise evaluates to the first condition that is true."
    },
    "(xor": {
        "prefix": "(xor",
        "body": [
            "(xor"
        ],
        "description": "xor [bool condition1] [bool condition2] ... [bool conditionN] || If an even number of condition expressions are true, evaluates to false. Otherwise evaluates to true."
    },
    "(not": {
        "prefix": "(not",
        "body": [
            "(not"
        ],
        "description": "not bool condition || Evaluates to false if condition is true, true if false."
    },
    "(=": {
        "prefix": "(=",
        "body": [
            "(="
        ],
        "description": "= [* node1] [* node2] ... [* nodeN] || Evaluates to true if all values are equal (will recurse into data structures), false otherwise. Values of nan (not a number) are considered equal because they represent the same node, unlike many other floating point representation systems."
    },
    "(!=": {
        "prefix": "(!=",
        "body": [
            "(!="
        ],
        "description": "!= [* node1] [* node2] ... [* nodeN] || Evaluates to true if no two values are equal (will recurse into data structures), false otherwise."
    },
    "(<": {
        "prefix": "(<",
        "body": [
            "(<"
        ],
        "description": "< [* node1] [* node2] ... [* nodeN] || Evaluates to true if all values are in strict increasing order, false otherwise."
    },
    "(<=": {
        "prefix": "(<=",
        "body": [
            "(<="
        ],
        "description": "<= [* node1] [* node2] ... [* nodeN] || Evaluates to true if all values are in nondecreasing order, false otherwise."
    },
    "(>": {
        "prefix": "(>",
        "body": [
            "(>"
        ],
        "description": "> [* node1] [* node2] ... [* nodeN] || Evaluates to true if all values are in strict decreasing order, false otherwise."
    },
    "(>=": {
        "prefix": "(>=",
        "body": [
            "(>="
        ],
        "description": ">= [* node1] [* node2] ... [* nodeN] || Evaluates to true if all values are in nonincreasing order, false otherwise."
    },
    "(~": {
        "prefix": "(~",
        "body": [
            "(~"
        ],
        "description": "~ [* node1] [* node2] ... [* nodeN] || Evaluates to true if all values are of the same data type, false otherwise."
    },
    "(!~": {
        "prefix": "(!~",
        "body": [
            "(!~"
        ],
        "description": "!~ [* node1] [* node2] ... [* nodeN] || Evaluates to true if no two values are of the same data types, false otherwise."
    },
    "(rand": {
        "prefix": "(rand",
        "body": [
            "(rand"
        ],
        "description": "rand [list|number range] [number number_to_generate] [bool unique] || With no parameters, evaluates to a random number between 0.0 and 1.0.  Each entity has its own random stream, and if called from a sandbox, then it uses a new stream without interrupting the stream of the calling entity. If the parameter is a list, it will uniformly randomly choose and evaluate to one element of the list. If number, it will evaluate to a value greater than or equal to zero and less than the number specified.  If  number_to_generate is specified, it will generate a list of multiple values (even if  number_to_generate is 1).  If unique is true (it defaults to false), then it will only return unique values, the same as selecting from the list or assoc without replacement."
    },
    "(weighted_rand": {
        "prefix": "(weighted_rand",
        "body": [
            "(weighted_rand"
        ],
        "description": "weighted_rand [list of lists|assoc weighted_values] [number number_to_generate] [bool unique] || Each entity has its own random stream, and if called from a sandbox, then it uses a new stream without interrupting the stream of the calling entity. If the parameter is a list, it will uniformly randomly choose and evaluate to one element of the list. If an assoc, then it will randomly evaluate to one of the keys using the values as the weights for the probabilities.  Nans and negative numbers are treated as zero.  Infinities are normalized as to only select from infinities in the list.  If all values are 0, then they are normalized to having the same weight. If a list of lists, it will use the first list as a list of values and the second list as a list of weights and otherwise work like it would for an assoc.  If  number_to_generate is specified, it will generate a list of multiple values (even if  number_to_generate is 1).  If unique is true (it defaults to false), then it will only return unique values, the same as selecting from the list or assoc without replacement."
    },
    "(get_rand_seed": {
        "prefix": "(get_rand_seed",
        "body": [
            "(get_rand_seed"
        ],
        "description": "get_rand_seed || Evaluates to a string representing the current state of the random number generator used for the rand command for the entity specified by id."
    },
    "(set_rand_seed": {
        "prefix": "(set_rand_seed",
        "body": [
            "(set_rand_seed"
        ],
        "description": "set_rand_seed * node || Sets the random number seed and state for the current random number stream without affecting any entity.  If node is already a string in the proper format output by get_entity_rand_seed, then it will set the random generator to that current state, picking up where the previous state left off.  If it is anything else, it uses the value as a random seed to start the genrator."
    },
    "(system_time": {
        "prefix": "(system_time",
        "body": [
            "(system_time"
        ],
        "description": "system_time || Evaluates to the current system time since epoch in seconds (including fractions of seconds)."
    },
    "(true": {
        "prefix": "(true",
        "body": [
            "(true"
        ],
        "description": "true || Evaluates to the immediate value true."
    },
    "(false": {
        "prefix": "(false",
        "body": [
            "(false"
        ],
        "description": "false || Evaluates to the immediate value false."
    },
    "(null": {
        "prefix": "(null",
        "body": [
            "(null"
        ],
        "description": "null || Evaluates to the immediate null value."
    },
    "(list": {
        "prefix": "(list",
        "body": [
            "(list"
        ],
        "description": "list [* node1] [* node2] ... [* nodeN] || Evaluates to the list specified by the parameters.  Pushes a new target scope such that (target), (current_index), and (current_value) access the list, the current index, and the current value."
    },
    "(assoc": {
        "prefix": "(assoc",
        "body": [
            "(assoc"
        ],
        "description": "assoc [bstring index1] [* value1] [bstring index1] [* value2] ... || Evaluates to the associative list, where each pair of parameters (e.g., index1 and value1) comprises a index/value pair. Pushes a new target scope such that (target), (current_index), and (current_value) access the assoc, the current index, and the current value.  If any of the bstrings do not have reserved characters or spaces, then quotes are optional; if spaces or reserved characters are present, then quotes are required."
    },
    "([number]": {
        "prefix": "([number]",
        "body": [
            "([number]"
        ],
        "description": "[number] || A 64-bit floating point value"
    },
    "([string]": {
        "prefix": "([string]",
        "body": [
            "([string]"
        ],
        "description": "[string] || A string."
    },
    "([symbol]": {
        "prefix": "([symbol]",
        "body": [
            "([symbol]"
        ],
        "description": "[symbol] || A string representing an internal symbol (a variable)."
    },
    "(get_type": {
        "prefix": "(get_type",
        "body": [
            "(get_type"
        ],
        "description": "get_type * node || Returns a node of the type corresponding to the node."
    },
    "(get_type_string": {
        "prefix": "(get_type_string",
        "body": [
            "(get_type_string"
        ],
        "description": "get_type_string * node || Returns a string that represents the type corresponding to the node."
    },
    "(set_type": {
        "prefix": "(set_type",
        "body": [
            "(set_type"
        ],
        "description": "set_type * node1 [string|* type] || Creates a copy of node1, setting the type of the node of to whatever node type is specified by string or to the same type as the top node of type.  It will convert the parameters to or from assoc if necessary."
    },
    "(format": {
        "prefix": "(format",
        "body": [
            "(format"
        ],
        "description": "format * data string from_format string to_format [assoc from_params] [assoc to_params] || Converts data from from_format into to_format.  Supported language types are \"number\", \"string\", and \"code\", where code represents everything beyond number and string.  Beyond the supported language types, additional formats that are stored in a binary string.  The additional formats are \"Base16\", \"Base64\", \"int8\", \"uint8\", \"int16\", \"uint16\", \"int32\", \"uint32\", \"int64\", \"uint64\", \"float\", \"double\", \"INT8\", \"UINT8\", \"INT16\", \"UINT16\", \"INT32\", \"UINT32\", \"INT64\", \"UINT64\", \"FLOAT\", \"DOUBLE\", \"json\", \"yaml\", and \"date\" (though date is a special case).  Lower case binary types names represent little endian and upper case binary type names represent big endian, and binary types will be handled as strings.  The \"date\" type requires additional information.  Following \"date\" is a colon, followed by a standard strftime date format string.  If from_params or to_params are specified, then it will apply the appropriate from or to as appropriate.  If the format is either \"string\", \"json\", or \"yaml\", then the key \"sort_keys\" can be used to specify a boolean value, if true, then it will sort the keys, otherwise the default behavior is to emit the keys based on memory layout.  If the format is date, then the to or from params can be an assoc with \"locale\" and \"timezone\" as optional keys, with the values representing the locale and timezone.  The locale is provided, then it will leverage operating system support to apply appropriate formatting, such as en_US.  Note that UTF-8 is assumed and automatically added to the locale.  If no locale is specified, then the default will be used.  If converting to or from dates, if timezone is specified, it will use the standard timezone name, if unspecified or empty string, it will assume the current time zone."
    },
    "(get_labels": {
        "prefix": "(get_labels",
        "body": [
            "(get_labels"
        ],
        "description": "get_labels * node || Returns a list of strings comprising all of the labels for the particular node of *."
    },
    "(get_all_labels": {
        "prefix": "(get_all_labels",
        "body": [
            "(get_all_labels"
        ],
        "description": "get_all_labels * node || Returns an associative list of the labels for the node of code and everything underneath it, where the index is the label and the value is the reference to *."
    },
    "(set_labels": {
        "prefix": "(set_labels",
        "body": [
            "(set_labels"
        ],
        "description": "set_labels * node (list [string new_label1]...[string new_labelN]) || Sets the labels for the node of code. Evaluates to the node represented by the input node."
    },
    "(zip_labels": {
        "prefix": "(zip_labels",
        "body": [
            "(zip_labels"
        ],
        "description": "zip_labels list labels * to_add_labels || For each of the values in to_add_labels, it takes respective value for labels and applies that string as a label to the respective value, and returns a new set of values with the labels."
    },
    "(get_comments": {
        "prefix": "(get_comments",
        "body": [
            "(get_comments"
        ],
        "description": "get_comments * node || Returns a strings comprising all of the comments for the input node."
    },
    "(set_comments": {
        "prefix": "(set_comments",
        "body": [
            "(set_comments"
        ],
        "description": "set_comments * node [string new_comment] || Sets the comments for the node of code. Evaluates to the node represented by new_comment."
    },
    "(get_concurrency": {
        "prefix": "(get_concurrency",
        "body": [
            "(get_concurrency"
        ],
        "description": "get_concurrency * node || Returns true if the node has a preference to be processed in a manner where its operations are run concurrently (and potentially subject to race conditions).  False if it is not."
    },
    "(set_concurrency": {
        "prefix": "(set_concurrency",
        "body": [
            "(set_concurrency"
        ],
        "description": "set_concurrency * node bool concurrent || Sets whether the node has a preference to be processed in a manner where its operations are run concurrently (and potentially subject to race conditions). Evaluates to the node represented by the input node."
    },
    "(get_value": {
        "prefix": "(get_value",
        "body": [
            "(get_value"
        ],
        "description": "get_value * node || Returns just the value portion of node (no labels or comments). Will evaluate to a copy of the value if it is not a unique reference, making it useful to ensure that the copy of the data is unique."
    },
    "(set_value": {
        "prefix": "(set_value",
        "body": [
            "(set_value"
        ],
        "description": "set_value * target * val || Sets target's value to the value of val, keeping existing labels, and comments)."
    },
    "(explode": {
        "prefix": "(explode",
        "body": [
            "(explode"
        ],
        "description": "explode [string str] [number stride] || Explodes string str into the pieces that make it up.  If stride is zero or unspecified, then it explodes the string by character per UTF-8 parsing.  If stride is specified, then it breaks it into chunks of that many bytes.  For example, a stride of 1 would break it into bytes, whereas a stride of 4 would break it into 32-bit chunks."
    },
    "(split": {
        "prefix": "(split",
        "body": [
            "(split"
        ],
        "description": "split [string str] [string split_string] [number max_split_count] [number stride] || Splits the string str into a list of strings based on the split_string, which is handled as a regular expression.  Any data matching split_string will not be included in any of the resulting strings.  If max_split_count is provided and greater than zero, it will only split up to that many times.  If stride is zero or unspecified, then it explodes the string by character per UTF-8 parsing.  If stride is specified and a value other than zero, then it does not use split_string as a regular expression but rather a string, and it breaks the result into chunks of that many bytes.  For example, a stride of 1 would break it into bytes, whereas a stride of 4 would break it into 32-bit chunks."
    },
    "(substr": {
        "prefix": "(substr",
        "body": [
            "(substr"
        ],
        "description": "substr [string str] [number|string location] [number|string param] [string replacement] [number stride] || Finds a substring of string str.  If location is a number, then evaluates to a new string representing the substring starting at offset, but if location is a string, then it will treat location as a regular expression.  If param is specified, if location is a number it will go until that length beyond the offset, and if location is a regular expression param will represent one of the following: if null or \"first\", then it will return the first match of the regular expression; if param is a number or the string \"all\", then substr will evaluate to a list of up to param matches (which may be infinite yielding the same result as \"all\").  If param is a negative number or the string \"submatches\", then it will return a list of list of strings, for each match up to the count of the negative number or all matches if \"submatches\", each inner list will represent the full regular expression match followed by each submatch as captured by parenthesis in the regular expression, ordered from an outer to inner, left-to-right manner.  If location is a number and offset or length are negative, then it will measure from the end of the string rather than the beginning.  If replacement is specified and not null, it will return the original string rather than the substring, but the substring will be replaced by replacement regardless of what location is; and if replacement is specified, then it will override some of the logic for the param type and always return just a string and not a list.  If stride is zero or unspecified, then it explodes the string by character per UTF-8 parsing.  If stride is specified, then it breaks it into chunks of that many bytes.  For example, a stride of 1 would break it into bytes, whereas a stride of 4 would break it into 32-bit chunks."
    },
    "(concat": {
        "prefix": "(concat",
        "body": [
            "(concat"
        ],
        "description": "concat [string str1] [string str2] ... [string strN] || Concatenates all strings and evaluates to the single string that is the result."
    },
    "(crypto_sign": {
        "prefix": "(crypto_sign",
        "body": [
            "(crypto_sign"
        ],
        "description": "crypto_sign string message string secret_key || Signs the message given the secret key and returns the signature using the Ed25519 algorithm.  Note that the message is not included in the signature.  The system opcode using the command sign_key_pair can be used to create a public/secret key pair."
    },
    "(crypto_sign_verify": {
        "prefix": "(crypto_sign_verify",
        "body": [
            "(crypto_sign_verify"
        ],
        "description": "crypto_sign_verify string message string public_key string signature || Verifies that the message was signed with the signature via the public key using the Ed25519 algorithm and returns true if the signature is valid, false otherwise.  Note that the message is not included in the signature.  The system opcode using the command sign_key_pair can be used to create a public/secret key pair."
    },
    "(encrypt": {
        "prefix": "(encrypt",
        "body": [
            "(encrypt"
        ],
        "description": "encrypt string plaintext_message string key1 [string nonce] [string key2] || If key2 is not provided, then it uses the XSalsa20 algorithm to perform shared secret key encryption on the message, returning the encrypted value.  If key2 is provided, then the Curve25519 algorithm will additionally be used, and key1 will represent the receiver's public key and key2 will represent the sender's secret key.  The nonce is a string of bytes up to 24 bytes long, that will be used to randomize the encryption, and will need to be provided to the decryption in order to work.  Nonces are not technically required, but strongly recommended to prevent replay attacks.  The system opcode using the command encrypt_key_pair can be used to create a public/secret key pair."
    },
    "(decrypt": {
        "prefix": "(decrypt",
        "body": [
            "(decrypt"
        ],
        "description": "decrypt string cyphertext_message string key1 [string nonce] [string key2] || If key2 is not provided, then it uses the XSalsa20 algorithm to perform shared secret key decryption on the message, returning the encrypted value.  If key2 is provided, then the Curve25519 algorithm will additionally be used, and key1 will represent the sender's public key and key2 will represent the receiver's secret key.  The nonce is a string of bytes up to 24 bytes long, that will be used to randomize the encryption, and will need to be provided to the decryption in order to work.  Nonces are not technically required, but strongly recommended to prevent replay attacks.  The system opcode using the command encrypt_key_pair can be used to create a public/secret key pair."
    },
    "(print": {
        "prefix": "(print",
        "body": [
            "(print"
        ],
        "description": "print [* node1] [* node2] ... [* nodeN] || Prints each of the parameters in order in a manner interpretable as if they were code. Output is pretty-printed. Printing a node which evaluates to a literal string or number will not be printed (the value will be printed directly) and not have a newline appended."
    },
    "(total_size": {
        "prefix": "(total_size",
        "body": [
            "(total_size"
        ],
        "description": "total_size * node || Evaluates to the total count of all of the nodes referenced within the input node. Each label on a node counts for an additional node.  The volume of data in an individual node (such as in a string) counts as an additional node for each 48 characters."
    },
    "(mutate": {
        "prefix": "(mutate",
        "body": [
            "(mutate"
        ],
        "description": "mutate * node [number mutation_rate] [assoc mutation_weights] [assoc operation_type] || Evaluates to a mutated version of the input node.  The value specified in mutation_rate, from 0.0 to 1.0 and defaulting to 0.00001, indicates the probability that any node will experience a mutation. The parameter mutation_weights is an assoc where the keys are the allowed opcode names and the values are the probabilities that each opcode would be chosen; if null or unspecified, it defaults to all opcodes each with their own default probability.  The operation_type is an assoc where the keys are mutation operations and the values are the probabilities that the operations will be performed.  The operations can consist of the strings change_type, delete, insert, swap_elements, deep_copy_elements, delete_elements, and change_label."
    },
    "(commonality": {
        "prefix": "(commonality",
        "body": [
            "(commonality"
        ],
        "description": "commonality * node1 * node2 [bool use_string_edit_distance] || Evaluates to the total count of all of the nodes referenced within node1 and node2 that are equivalent, using fractions to represent somewhat similar nodes. If use_string_edit_distance is true and node1 and node2 are both string literals, string edit distance will be used to calculate commonality."
    },
    "(edit_distance": {
        "prefix": "(edit_distance",
        "body": [
            "(edit_distance"
        ],
        "description": "edit_distance * node1 * node2 [bool use_string_edit_distance] || Evaluates to the number of nodes that are different between 1 and 2, using fractions to represent somewhat similar nodes. If use_string_edit_distance is true and node1 and node2 are both string literals, string edit distance will be calculated."
    },
    "(intersect": {
        "prefix": "(intersect",
        "body": [
            "(intersect"
        ],
        "description": "intersect * node1 * node2 || Evaluates to whatever is common between node1 and node2 exclusive."
    },
    "(union": {
        "prefix": "(union",
        "body": [
            "(union"
        ],
        "description": "union * node1 * node2 || Evaluates to whatever is inclusive when merging node1 and node2."
    },
    "(difference": {
        "prefix": "(difference",
        "body": [
            "(difference"
        ],
        "description": "difference * node1 * node2 || Finds the difference between node1 and node2, and generates code that, if evaluated passing node1 as its parameter \"_\", would turn it into node2.  Useful for finding the smallest set of what needs to be changed to apply it to new (and possibly slightly different) data or code."
    },
    "(mix": {
        "prefix": "(mix",
        "body": [
            "(mix"
        ],
        "description": "mix * node1 * node2 [number keep_chance_node1] [number keep_chance_node2] [number similar_mix_chance] || Performs a union operation on node1 and node2, but randomly ignores nodes from one or the other if the node is not equal.  If only keep_chance_node1 is specified, keep_chance_node2 defaults to 1-keep_chance_node1. keep_chance_node1 specifies the probability that a node from node1 will be kept, and keep_chance_node2 the probability that a node from node2 will be kept.  keep_chance_node1 + keep_chance_node2 should be between 1 and 2, otherwise it will be normalized.  similar_mix_chance is the additional probability that two nodes will mix if they have some commonality, which will include interpolating number values based on keep_chance_node1 and keep_chance_node2, and defaults to 0.0.  If similar_mix_chance is negative, then 1 minus the value will be anded with the commonality probability, so -1 means that it will never mix and 0 means it will only mix when sufficiently common."
    },
    "(mix_labels": {
        "prefix": "(mix_labels",
        "body": [
            "(mix_labels"
        ],
        "description": "mix_labels * node1 * node2 [number keep_portion] [number keep_portion_node2] || Starts with node1, and for all common labels between node1 and node2, mixes node2 into node1.  If keep_portion is given, then that is the fraction of matching labels in node2 to use in node1. If both keep_portion and keep_portion_node2 are given, then those are the fractions of labels in node1 and node2 to be used.  If the sum is greater than 1 it is normalized, if less, then some labeled code is discarded from node1."
    },
    "(total_entity_size": {
        "prefix": "(total_entity_size",
        "body": [
            "(total_entity_size"
        ],
        "description": "total_entity_size id entity || Evaluates to the total count of all of the nodes of the entity represented by the input id and all its contained entities."
    },
    "(flatten_entity": {
        "prefix": "(flatten_entity",
        "body": [
            "(flatten_entity"
        ],
        "description": "flatten_entity id entity [bool include_rand_seeds] [bool parallel_create] || Evaluates to code that, if evaluated, would completely reproduce the entity specified by id, as well as all contained entities.  If include_rand_seeds is true, its default, it will include all entities' random seeds.  If parallel_create is true, then the creates will be performed with parallel markers as appropriate for each group of contained entities."
    },
    "(mutate_entity": {
        "prefix": "(mutate_entity",
        "body": [
            "(mutate_entity"
        ],
        "description": "mutate_entity id entity1 [number mutaton_rate] [id entity2] [assoc mutation_weights] [assoc operation_type] || Creates a mutated version of the entity specified by entity1 like mutate. Returns the id of a new entity created contained by the entity that ran it.  The value specified in mutation_rate, from 0.0 to 1.0 and defaulting to 0.00001, indicates the probability that any node will experience a mutation.  Uses entity2 as the optional destination via an internal call to create_contained_entity. The parameter mutation_weights is an assoc where the keys are the allowed opcode names and the values are the probabilities that each opcode would be chosen; if null or unspecified, it defaults to all opcodes each with their own default probability.  The operation_type is an assoc where the keys are mutation operations and the values are the probabilities that the operations will be performed.  The operations can consist of the strings change_type, delete, insert, swap_elements, deep_copy_elements, delete_elements, and change_label."
    },
    "(commonality_entities": {
        "prefix": "(commonality_entities",
        "body": [
            "(commonality_entities"
        ],
        "description": "commonality_entities id entity1 id entity2 || Evaluates to the total count of all of the nodes referenced within entity1 and entity2 that are equivalent, including all contained entities."
    },
    "(edit_distance_entities": {
        "prefix": "(edit_distance_entities",
        "body": [
            "(edit_distance_entities"
        ],
        "description": "edit_distance_entities id entity1 id entity2 || Evaluates to the edit distance of all of the nodes referenced within entity1 and entity2 that are equivalent, including all contained entities."
    },
    "(intersect_entities": {
        "prefix": "(intersect_entities",
        "body": [
            "(intersect_entities"
        ],
        "description": "intersect_entities id entity1 id entity2 [id entity3] || Creates an entity of whatever is common between the Entities represented by entity1 and entity2 exclusive.  Returns the id of a new entity created contained by the entity that ran it.  Uses entity3 as the optional destination via an internal call create_contained_entity. Any contained entities will be intersected either based on matching name or maximal similarity for nameless entities."
    },
    "(union_entities": {
        "prefix": "(union_entities",
        "body": [
            "(union_entities"
        ],
        "description": "union_entities id entity1 id entity2 [id entity3] || Creates an entity of whatever is inclusive when merging the Entities represented by entity1 and entity2.  Returns the id of a new entity created contained by the entity that ran it.  Uses entity3 as the optional destination via an internal call to create_contained_entity.  Any contained entities will be unioned either based on matching name or maximal similarity for nameless entities."
    },
    "(difference_entities": {
        "prefix": "(difference_entities",
        "body": [
            "(difference_entities"
        ],
        "description": "difference_entities id entity1 id entity2 || Finds the difference between the entities specified by entity1 and entity2 and generates code that, if evaluated passing the entity id as its parameter \"_\", would turn it into entity entity2 (creating or removing any contained entities as necessary).  Useful for finding the smallest set of what needs to be changed to apply it to a new (and possibly slightly different) entity."
    },
    "(mix_entities": {
        "prefix": "(mix_entities",
        "body": [
            "(mix_entities"
        ],
        "description": "mix_entities id entity1 id entity2 [number keep_chance_entity1] [number keep_chance_entity2] [number similar_mix_chance] [number chance_mix_unnamed_children] [id entity3] || Performs a union operation on the entities represented by entity1 and entity2, but randomly ignores nodes from one or the other tree if not equal.  If only keep_chance_entity1 is specified, keep_chance_entity2 defaults to 1-keep_chance_entity1.  keep_chance_entity1 specifies the probability that a node from the entity represented by entity1 will be kept, and keep_chance_entity2 the probability that a node from the entity represented by entity2 will be kept.  similar_mix_chance is the additional probability that two nodes will mix if they have some commonality, which will include interpolating number values based on keep_chance_node1 and keep_chance_node2, and defaults to 0.0.  If similar_mix_chance is negative, then 1 minus the value will be anded with the commonality probability, so -1 means that it will never mix and 0 means it will only mix when sufficiently common.  chance_mix_unnamed_children represents the probability that an unnamed entity pair will be mixed versus preserved as independent chunks, where 0.2 would yield 20% of the entities mixed. Returns the id of a new entity created contained by the entity that ran it.  Uses entity3 as the optional destination via an internal call to create_contained_entity.   Any contained entities will be mixed either based on matching name or maximal similarity for nameless entities."
    },
    "(get_entity_comments": {
        "prefix": "(get_entity_comments",
        "body": [
            "(get_entity_comments"
        ],
        "description": "get_entity_comments [id entity] [string label] [bool deep_comments] || Evaluates to the corresponding comments based on the parameters.  If the id is specified or null is specified as the id, then it will use the current entity.  If the label is null or empty string, it will retrieve comments for the entity root, otherwise if it is a valid label it will attempt to retrieve the comments for that label, null if the label doesn't exist.  If deep_comments is specified and the label is a declare, then it will return an assoc with the keys being the parameters and the values being the descriptions.  If label is empty string or null and deep_comments is true, then it will return an assoc of label to comment for each label in the entity."
    },
    "(retrieve_entity_root": {
        "prefix": "(retrieve_entity_root",
        "body": [
            "(retrieve_entity_root"
        ],
        "description": "retrieve_entity_root [id entity] [bool suppress_label_escapes] || Evaluates to the entity's code, looking up the entity by the id. If no id specified or the id is null, then uses the current entity, otherwise accesses a contained entity. If suppress_label_escapes is false or omitted, will disable any labels obtained by inserting an extra # at the beginning of each."
    },
    "(assign_entity_roots": {
        "prefix": "(assign_entity_roots",
        "body": [
            "(assign_entity_roots"
        ],
        "description": "assign_entity_roots [id entity_1] * root_1 [id entity_2] [* root_2] [...] || Sets the code of the entity specified by id to node.  If no id specified, then uses the current entity, otherwise accesses a contained entity. On assigning the code to the new entity, it will enable any labels obtained by removing any extra #s from the beginning of each.  If all assignments were successful, then returns true, otherwise returns false."
    },
    "(accum_entity_roots": {
        "prefix": "(accum_entity_roots",
        "body": [
            "(accum_entity_roots"
        ],
        "description": "accum_entity_roots [id entity_1] * root_1 [id entity_2] [* root_2] [...] || Accumulates the code of the entity specified by id to node. If no id specified, then uses the current entity, otherwise accesses a contained entity. On assigning the code to the new entity, it will enable any labels obtained by removing any extra #s from the beginning of each.  If all accumulations were successful, then returns true, otherwise returns false."
    },
    "(get_entity_rand_seed": {
        "prefix": "(get_entity_rand_seed",
        "body": [
            "(get_entity_rand_seed"
        ],
        "description": "get_entity_rand_seed id entity || Evaluates to a string representing the current state of the random number generator for the entity specified by id used for seeding the random streams of any calls to the entity."
    },
    "(set_entity_rand_seed": {
        "prefix": "(set_entity_rand_seed",
        "body": [
            "(set_entity_rand_seed"
        ],
        "description": "set_entity_rand_seed [id entity] * node [bool deep] || Sets the random number seed and state for the random number generator of the specified entity, or the current entity if not specified, to the state specified by node.  If node is already a string in the proper format output by get_entity_rand_seed, then it will set the random generator to that current state, picking up where the previous state left off.  If it is anything else, it uses the value as a random seed to start the genrator.  Note that this will not affect the state of the current random number stream, only future random streams created by the entity for new calls.  The parameter deep defaults to false, but if it is true, all contained entities are recursively set with random seeds based on the specified random seed and a hash of their relative id path to the entity being set."
    },
    "(get_entity_root_permission": {
        "prefix": "(get_entity_root_permission",
        "body": [
            "(get_entity_root_permission"
        ],
        "description": "get_entity_root_permission id entity || Returns true if the entity has root permissions, false if not.  Will return null if the caller is not root."
    },
    "(set_entity_root_permission": {
        "prefix": "(set_entity_root_permission",
        "body": [
            "(set_entity_root_permission"
        ],
        "description": "set_entity_root_permission id entity bool permission || Sets the root permission on the entity specified by id.  If bool is true, then it grants permissions, if it is false, then it removes them.  Returns the id of the entity.  Can only be called by an entity with root permissions."
    },
    "(create_entities": {
        "prefix": "(create_entities",
        "body": [
            "(create_entities"
        ],
        "description": "create_entities [id entity_1] * node_1 [id entity_2] [* node_2] [...] || Creates a new entity with code specified by node.  Uses the optional entity location specified by the id, ignored if null or invalid.  Evaluates to a list of all of the new entities ids, null in place of each id if it was unable to create the id.  If the entity does not have permission to create the entities, it will evaluate to null.  If the id is ommitted, then it will create the new entity in the calling entity.  If id specifies an existing entity, then it will create the new entity within that existing entity.  If the last id in the string is not an existing entity, then it will attempt to create that entity (returning null if it cannot).  Can only be performed by an entity that contains to the destination specified by id. Will automatically remove a # from the beginning of each label in case the label had been disabled.  Unlike the rest of the entity creation commands, create_entities specifies the optional id first to make it easy to read entity definitions.  If more than 2 parameters are specified, create_entities will iterate through all of the pairs of parameters, treating them like the first two as it creates new entities."
    },
    "(clone_entities": {
        "prefix": "(clone_entities",
        "body": [
            "(clone_entities"
        ],
        "description": "clone_entities id source_entity_1 [id destination_entity_1] [id source_entity_2] [id destination_entity_2] [...] || Creates a clone of source_entity_1.  If destination_entity_1 is not specified, then it clones the entity into the current entity.  If destination_entity_1 is specified, then it clones it into the location specified by destination_entity_1; if destination_entity_1 is an existing entity, then it will create it within that entity, if not, it will attempt to create it with the given id.  Evaluates to the id of the new entity.  Can only be performed by an entity that contains both source_entity_1 and the specified path of destination_entity_1. If multiple entities are specified, it will move each from the source to the destination.  Evaluates to a list of the new entity ids."
    },
    "(move_entities": {
        "prefix": "(move_entities",
        "body": [
            "(move_entities"
        ],
        "description": "move_entities id source_entity_1 [id destination_entity_1] [id source_entity_2] [id destination_entity_2] [...] || Moves the entity from location specified by source_entity_1 to destination destination_entity_1.  If destination_entity_1 exists, it will move source_entity_1 using source_entity_1's current id into destination_entity_1.  If destination_entity_1 does not exist, then it will move source_entity_1 and rename it to the end of the id specified in destination_entity_1. Can only be performed by a containing entity relative to both ids.  If multiple entities are specified, it will move each from the source to the destination.  Evaluates to a list of the new entity ids."
    },
    "(destroy_entities": {
        "prefix": "(destroy_entities",
        "body": [
            "(destroy_entities"
        ],
        "description": "destroy_entities [id entity_1] [id entity_2] [...] || Destroys the entities specified by the ids entity_1, entity_2, etc. Can only be performed by containing entity.  Retruns true if all entities were successfully destroyed, false if not due to not existing in the first place or due to code being currently run in it."
    },
    "(load": {
        "prefix": "(load",
        "body": [
            "(load"
        ],
        "description": "load string file_path [bool escape_filename] [string file_type] || Loads the data specified by the resource in string.  Attempts to load the file type and parse it into appropriate data and evaluate to the corresponding code. The parameter escape_filename defaults to false, but if it is true, it will agressively escape filenames using only alphanumeric characters and the underscore, using underscore as an escape character.  If file_type is specified and not null, it will use the file_type specified instead of the extension of the file_path.  File formats supported are amlg, json, yaml, csv, cstl, and caml; anything not in this list will be loaded as a binary string.  Note that loading from a non-'.amlg' extension will only ever provide lists, assocs, numbers, and strings."
    },
    "(load_entity": {
        "prefix": "(load_entity",
        "body": [
            "(load_entity"
        ],
        "description": "load_entity string file_path [id entity] [bool escape_filename] [bool escape_contained_filenames] [string file_type] || Loads an entity specified by the resource in string.  Attempts to load the file type and parse it into appropriate data and store it in the entity specified by id, following the same id creation rules as create_entities, except that if no id is specified, it may default to a name based on the resource if available.  The parameter escape_filename defaults to false, but if it is true, it will agressively escape filenames using only alphanumeric characters and the underscore, using underscore as an escape character.  If escape_contained_filenames is true, which is its default, it will also escape contained entity filenames. If file_type is specified and not null, it will use the file_type specified instead of the extension of the file_path.  File formats supported are amlg, json, yaml, csv, cstl, and caml; anything not in this list will be loaded as a binary string.  Note that loading from a non-'.amlg' extension will only ever provide lists, assocs, numbers, and strings."
    },
    "(load_persistent_entity": {
        "prefix": "(load_persistent_entity",
        "body": [
            "(load_persistent_entity"
        ],
        "description": "load_persistent_entity string file_path [id entity] [bool escape_filename] || Loads an entity specified by the resource in string.  Attempts to load the file type and parse it into appropriate data and store it in the entity specified by id, following the same id creation rules as create_entities. Any modifications to the entity or any entity contained within it will be written out to the resource, so that the memory and persistent storage are synchronized.  The parameter escape_filename defaults to false, but if it is true, it will agressively escape filenames using only alphanumeric characters and the underscore, using underscore as an escape character.  This command will escape contained filenames.  The file type of a persisted entity must match the extension of the file of the main entity.  File formats supported are amlg, json, yaml, csv, cstl, and caml; anything not in this list will be loaded as a binary string.  Note that loading from a non-'.amlg' extension will only ever provide lists, assocs, numbers, and strings.\n\n<b>WARNING:</b> Loading the same file as a persistent entity in more than one place will overwrite the file each time either entity is altered, but changes will not be propogated between the entities."
    },
    "(store": {
        "prefix": "(store",
        "body": [
            "(store"
        ],
        "description": "store string file_path * node [bool escape_filename] [string file_type] [assoc params] || Stores the code specified by * to the resource in string. Returns true if successful, false if not. The parameter escape_filename defaults to false, but if it is true, it will agressively escape filenames using only alphanumeric characters and the underscore, using underscore as an escape character.   If file_type is specified and not null, it will use the file_type specified instead of the extension of the file_path.  File formats supported are amlg, json, yaml, csv, cstl, and caml; anything not in this list will be loaded as a binary string.  Note that loading from a non-'.amlg' extension will only ever provide lists, assocs, numbers, and strings.  If params is specified, it is an assoc that contains key-value pairs describing the format.  The key \"sort_keys\" can be used to specify a boolean value, if true, then it will sort the keys, otherwise the default behavior is to emit the keys based on memory layout."
    },
    "(store_entity": {
        "prefix": "(store_entity",
        "body": [
            "(store_entity"
        ],
        "description": "store_entity string file_path id entity [bool escape_filename] [bool escape_contained_filenames] [string file_type] [assoc params] || Stores the entity specified by the id to the resource in string. Returns true if successful, false if not. The parameter escape_filename defaults to false, but if it is true, it will agressively escape filenames using only alphanumeric characters and the underscore, using underscore as an escape character.  If escape_contained_filenames is true, which is its default, it will also escape contained entity filenames.  If file_type is specified and not null, it will use the file_type specified instead of the extension of the file_path.  File formats supported are amlg, json, yaml, csv, cstl, and caml; anything not in this list will be loaded as a binary string.  Note that loading from a non-'.amlg' extension will only ever provide lists, assocs, numbers, and strings.  If params is specified, it is an assoc that contains key-value pairs describing the format.  The key \"sort_keys\" can be used to specify a boolean value, if true, then it will sort the keys, otherwise the default behavior is to emit the keys based on memory layout."
    },
    "(contains_entity": {
        "prefix": "(contains_entity",
        "body": [
            "(contains_entity"
        ],
        "description": "contains_entity id entity || Returns true if the referred to entity specified by id exists."
    },
    "(contained_entities": {
        "prefix": "(contained_entities",
        "body": [
            "(contained_entities"
        ],
        "description": "contained_entities [id containing_entity] [list conditions] || Returns a list of strings of ids of entities contained in the entity specified by id or current entity if id is ommitted.  The optional list is a conjunction of conditions that are required in order for a contained entity to be returned.  The conditions are all of the commands that begin with query_."
    },
    "(compute_on_contained_entities": {
        "prefix": "(compute_on_contained_entities",
        "body": [
            "(compute_on_contained_entities"
        ],
        "description": "compute_on_contained_entities [id containing_entity] [list conditions] || Performs queries like contained_entities but returns a value or set of values appropriate for the last query in conditions.  The parameter conditions is a conjunction of conditions that are required in order for the final query to be evaluated.  Each entity in the list is a query.  The conditions are all of the commands that begin with query_.  If the last query does not return anything, then it will just return the matching entities."
    },
    "(query_count": {
        "prefix": "(query_count",
        "body": [
            "(query_count"
        ],
        "description": "query_count || When used as a compute_on_contained_entities argument, counts the number of entities that match the criteria and returns the number."
    },
    "(query_select": {
        "prefix": "(query_select",
        "body": [
            "(query_select"
        ],
        "description": "query_select number num_to_select [number start_offset] [number random_seed] || When used as a query argument, selects num_to_select entities sorted by entity id.  If start_offset is specified, then it will return num_to_select starting that far in, and subsequent calls can be used to get all entities in batches.  If random_seed is specified, then it will select num_to_select entities randomly from the list based on the random seed.  If random_seed is specified and start_offset is null, then it will not guarantee a position in the order for subsequent calls that specify start_offset, and will execute more quickly."
    },
    "(query_sample": {
        "prefix": "(query_sample",
        "body": [
            "(query_sample"
        ],
        "description": "query_sample number num_to_select [number random_seed] || When used as a query argument, selects a random sample of num_to_select entities sorted by entity_id with replacement. If random_seed is specified, then it will select num_to_select entities randomly from the list based on the random seed. If random_seed is not specified then the subsequent calls will return the same sample of entities."
    },
    "(query_weighted_sample": {
        "prefix": "(query_weighted_sample",
        "body": [
            "(query_weighted_sample"
        ],
        "description": "query_weighted_sample string weight_label_name number num_to_select [number random_seed] || When used as a query argument, selects a random sample of num_to_select entities sorted by entity_id with replacement. It will use weight_label_name as the feature containing the weights for the sampling, which will be normalized prior to sampling.  Non-numbers and negative infinite values will be ignored, and if there are any infinite values, those will be selected from uniformly.  If random_seed is specified, then it will select num_to_select entities randomly from the list based on the random seed. If random_seed is not specified then the subsequent calls will return the same sample of entities."
    },
    "(query_in_entity_list": {
        "prefix": "(query_in_entity_list",
        "body": [
            "(query_in_entity_list"
        ],
        "description": "query_in_entity_list list list_of_entity_ids || When used as a query argument, selects only the entities in list_of_entity_ids.  It can be used to filter results before doing subsequent queries."
    },
    "(query_not_in_entity_list": {
        "prefix": "(query_not_in_entity_list",
        "body": [
            "(query_not_in_entity_list"
        ],
        "description": "query_not_in_entity_list list list_of_entity_ids || When used as a query argument, filters out the entities in list_of_entity_ids.  It can be used to filter results before doing subsequent queries."
    },
    "(query_exists": {
        "prefix": "(query_exists",
        "body": [
            "(query_exists"
        ],
        "description": "query_exists string label_name || When used as a query argument, selects entities which have the named label.  If called last with compute_on_contained_entities, then it returns an assoc of entity ids, where each value is an assoc of corresponding label names and values."
    },
    "(query_not_exists": {
        "prefix": "(query_not_exists",
        "body": [
            "(query_not_exists"
        ],
        "description": "query_not_exists string label_name || When used as a query argument, selects entities which do not have the named label."
    },
    "(query_equals": {
        "prefix": "(query_equals",
        "body": [
            "(query_equals"
        ],
        "description": "query_equals string label_name * node_value || When used as a query argument, selects entities for which the specified label is equal to the specified *."
    },
    "(query_not_equals": {
        "prefix": "(query_not_equals",
        "body": [
            "(query_not_equals"
        ],
        "description": "query_not_equals string label_name * node_value || When used as a query argument, selects entities for which the specified label is not equal to the specified *."
    },
    "(query_between": {
        "prefix": "(query_between",
        "body": [
            "(query_between"
        ],
        "description": "query_between string label_name * lower_bound * upper_bound || When used as a query argument, selects entities for which the specified label has a value between the specified lower_bound an upper_bound."
    },
    "(query_not_between": {
        "prefix": "(query_not_between",
        "body": [
            "(query_not_between"
        ],
        "description": "query_not_between string label_name * lower_bound * upper_bound || When used as a query argument, selects entities for which the specified label has a value outside the specified lower_bound an upper_bound."
    },
    "(query_among": {
        "prefix": "(query_among",
        "body": [
            "(query_among"
        ],
        "description": "query_among string label_name list values || When used as a query argument, selects entities for which the specified label has one of the values specified in values."
    },
    "(query_not_among": {
        "prefix": "(query_not_among",
        "body": [
            "(query_not_among"
        ],
        "description": "query_not_among string label_name list values || When used as a query argument, selects entities for which the specified label does not have one of the values specified in values."
    },
    "(query_max": {
        "prefix": "(query_max",
        "body": [
            "(query_max"
        ],
        "description": "query_max string label_name [number entities_returned] [bool numeric] || When used as a query argument, selects a number of entities with the highest values in the specified label.  If entities_returned is specified, it will return that many entities, otherwise will return 1.  If numeric is true, its default value, then it only considers numeric values; if false, will consider all types."
    },
    "(query_min": {
        "prefix": "(query_min",
        "body": [
            "(query_min"
        ],
        "description": "query_min string label_name [number entities_returned] [bool numeric] || When used as a query argument, selects a number of entities with the lowest values in the specified label.  If entities_returned is specified, it will return that many entities, otherwise will return 1.  If numeric is true, its default value, then it only considers numeric values; if false, will consider all types."
    },
    "(query_sum": {
        "prefix": "(query_sum",
        "body": [
            "(query_sum"
        ],
        "description": "query_sum string label_name [string weight_label_name] || When used as a query argument, returns the sum of all entities over the specified label.  If weight_label_name is specified, it will find the weighted sum, which is the same as a dot product."
    },
    "(query_mode": {
        "prefix": "(query_mode",
        "body": [
            "(query_mode"
        ],
        "description": "query_mode string label_name [string weight_label_name] [bool numeric] || When used as a query argument, finds the statistical mode of label_name for numerical data.  If weight_label_name is specified, it will find the weighted mode.  If numeric is true, its default, then it will treat all values as numeric, otherwise it will treat them all as strings.  If numeric and no numeric mode exists, it will return .nan, but if string and no string mode exists, it will return null."
    },
    "(query_quantile": {
        "prefix": "(query_quantile",
        "body": [
            "(query_quantile"
        ],
        "description": "query_quantile string label_name [number q] [string weight_label_name] || When used as a query argument, finds the statistical quantile of label_name for numerical data, using q as the parameter to the quantile (default 0.5, median).  If weight_label_name is specified, it will find the weighted quantile, otherwise weight is 1."
    },
    "(query_generalized_mean": {
        "prefix": "(query_generalized_mean",
        "body": [
            "(query_generalized_mean"
        ],
        "description": "query_generalized_mean string label_name number p [string weight_label_name] [number center] [bool calculate_moment] [bool absolute_value] || When used as a query argument, computes the generalized mean over the label_name for numeric data, using p as the parameter to the generalized mean.  If weight_label_name is specified, it will compute a weighted mean, normalizing the values of contained by weight_label_name. If center is specified, calculations will use that as central point, default is 0.0. If calculate_moment is true, results will not be raised to 1/p for p>=1. If absolute_value is true, the first order mean (p=1) will take the absolute value."
    },
    "(query_min_difference": {
        "prefix": "(query_min_difference",
        "body": [
            "(query_min_difference"
        ],
        "description": "query_min_difference string label_name [number cyclic_range] [bool include_zero_difference] || When used as a query argument, finds the smallest difference between any two values for the specified label. If cyclic_range is null, the default value, then it will assume the values are not cyclic; if it is a number, then it will assume the range is from 0 to cyclic_range.  If include_zero_difference is true, its default value, then it will return 0 if the smallest gap between any two numbers is 0; if false, it will return the smallest nonzero value."
    },
    "(query_max_difference": {
        "prefix": "(query_max_difference",
        "body": [
            "(query_max_difference"
        ],
        "description": "query_max_difference string label_name [number cyclic_range] || When used as a query argument, finds the largest difference between any two values for the specified label. If cyclic_range is null, the default value, then it will assume the values are not cyclic; if it is a number, then it will assume the range is from 0 to cyclic_range."
    },
    "(query_value_masses": {
        "prefix": "(query_value_masses",
        "body": [
            "(query_value_masses"
        ],
        "description": "query_value_masses string label_name [string weight_label_name] [bool numeric] || When used as a query argument, computes the counts for each value of the label and returns an assoc with the keys being the label values and the values being the counts or weights of the values.  If weight_label_name is specified, then it will accumulate that weight for each value, otherwise it will use a weight of 1 for each yielding a count.  If numeric is true, its default, then it will treat all values as numeric, otherwise it will treat them all as strings."
    },
    "(query_less_or_equal_to": {
        "prefix": "(query_less_or_equal_to",
        "body": [
            "(query_less_or_equal_to"
        ],
        "description": "query_less_or_equal_to string label_name * max_value || When used as a query argument, selects entities with a value in the specified label less than or equal to the specified *."
    },
    "(query_greater_or_equal_to": {
        "prefix": "(query_greater_or_equal_to",
        "body": [
            "(query_greater_or_equal_to"
        ],
        "description": "query_greater_or_equal_to string label_name * min_value || When used as a query argument, selects entities with a value in the specified label greater than or equal to the specified *."
    },
    "(query_within_generalized_distance": {
        "prefix": "(query_within_generalized_distance",
        "body": [
            "(query_within_generalized_distance"
        ],
        "description": "query_within_generalized_distance number max_distance list axis_labels list axis_values list|assoc|number weights list|assoc distance_types list|assoc attributes list|assoc|number deviations [number p_value] [string|number distance_transform] [string entity_weight_label_name] [number random_seed] [string radius_label] [string numerical_precision] [* output_sorted_list] || When used as a query argument, selects entities which represent a point within a certain generalized norm to a given point. axis_labels specifies the names of the coordinate axes (as labels on the target entity), and axis_values the specifies the corresponding values for the point to test from. p_value is the generalized norm parameter. weights is a list or assoc of dimension weights to use for the query, each value mapping to its respective element in the vectors.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  For attributes, the particular distance_types specifies what is expected.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values available.  For continuous, a null means unbounded where distance for a null will be computed automatically from the relevant data; a single number indicates the difference between a value and a null, a specified uncertainty.  Cyclic requires either a single value or a list of two values; a list of two values indicates that the first value, the lower bound, will wrap around to the upper bound, the second value specified; if only a single number is provided instead of a list, then it will assume that number for the upper bound and 0 for the lower bound.  For the string distance type, the value specified can be a number indicating the maximum possible string length, inferred if null is provided.  For code, the value specified can be a number indicating the maximum number of nodes in the code (including labels), inferred if null is provided.  Deviations contains numbers that are used during the distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0. max_distance is the maximum distance allowed. The optional radius_label parameter represents the label name of the radius of the entity (if the radius is within the distance, the entity is selected). The optional numerical_precision represents one of three values: \"precise\", which computes every distance with high numerical precision, \"fast\", which computes every distance with lower but faster numerical precison, and \"recompute_precise\", which computes distances quickly with lower precision but then recomputes any distance values that will be returned with higher precision. If called last with compute_on_contained_entities, then it returns an assoc of the entity ids with their distances.  If these distances are returned, then a transform may be applied to them based on distance_transform.  If distance_transform is \"surprisal_to_prob\" then distances will be assumed to be surprisals and will be transformed back into probabilities before being returned.  If distance_transform is a number or omitted, which will default to 1.0, then it will be treated as a distance weight exponent, and will be applied to each distance as distance^distance_weight_exponent.  If entity_weight_label_name is specified, it will multiply the resulting value for each entity (after distance_weight_exponent, etc. have been applied) by the value in the label of entity_weight_label_name. If output_sorted_list is not specified or is false, then it will return an assoc of entity string id as the key with the distance as the value; if output_sorted_list is true, then it will return a list of lists, where the first list is the entity ids and the second list contains the corresponding distances, where both lists are in sorted order starting with the closest or most important (based on whether distance_weight_exponent is positive or negative respectively). If output_sorted_list is a string, then it will additionally return a list where the values correspond to the values for each respective entity."
    },
    "(query_nearest_generalized_distance": {
        "prefix": "(query_nearest_generalized_distance",
        "body": [
            "(query_nearest_generalized_distance"
        ],
        "description": "query_nearest_generalized_distance number entities_returned list axis_labels list axis_values list|assoc weights list|assoc distance_types list|assoc attributes list|assoc deviations [number p_value] [string|number distance_transform] [string entity_weight_label_name] [number random_seed] [string radius_label] [string numerical_precision] [* output_sorted_list] || When used as a query argument, selects the closest entities which represent a point within a certain generalized norm to a given point. axis_labels specifies the names of the coordinate axes (as labels on the target entity), and axis_values the specifies the corresponding values for the point to test from. p_value is the generalized norm parameter. weights is a list or assoc of dimension weights to use for the query, each value mapping to its respective element in the vectors.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  \nFor attributes, the particular distance_types specifies what particular attributes are expected.  In all cases, there is the option to specify a list of values, where the second last value is the difference to use when one of the values being compared is null, and the last value is the difference to use when both of the values are null.  If the last value is omitted, it will use the second last value for both.  If both of the null values are omitted, then it will compute the maximum difference and use that for both.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values given.  Cyclic requires a single value, which is the upper bound of the difference for the cycle range (e.g., if the value is 360, then the supremum difference between two values will be 360, leading 1 and 359 to have a difference of 2).\n  Deviations contains numbers that are used during the distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0.  entities_returned specifies the number of entities to return. The optional radius_label parameter represents the label name of the radius of the entity (if the radius is within the distance, the entity is selected). The optional numerical_precision represents one of three values: \"precise\", which computes every distance with high numerical precision, \"fast\", which computes every distance with lower but faster numerical precison, and \"recompute_precise\", which computes distances quickly with lower precision but then recomputes any distance values that will be returned with higher precision.  If called last with compute_on_contained_entities, then it returns an assoc of the entity ids with their distances.  If these distances are returned, then a transform may be applied to them based on distance_transform.  If distance_transform is \"surprisal_to_prob\" then distances will be assumed to be surprisals and will be transformed back into probabilities before being returned.  If distance_transform is a number or omitted, which will default to 1.0, then it will be treated as a distance weight exponent, and will be applied to each distance as distance^distance_weight_exponent.  If entity_weight_label_name is specified, it will multiply the resulting value for each entity (after distance_weight_exponent, etc. have been applied) by the value in the label of entity_weight_label_name. If output_sorted_list is not specified or is false, then it will return an assoc of entity string id as the key with the distance as the value; if output_sorted_list is true, then it will return a list of lists, where the first list is the entity ids and the second list contains the corresponding distances, where both lists are in sorted order starting with the closest or most important (based on whether distance_weight_exponent is positive or negative respectively).  If output_sorted_list is a string, then it will additionally return a list where the values correspond to the values for each respective entity."
    },
    "(compute_entity_convictions": {
        "prefix": "(compute_entity_convictions",
        "body": [
            "(compute_entity_convictions"
        ],
        "description": "compute_entity_convictions number entities_returned list feature_labels list entity_ids_to_compute list|assoc weights list|assoc distance_types list|assoc attributes list|assoc deviations [number p_value] [string|number distance_transform] [string entity_weight_label_name] [number random_seed] [string radius_label] [string numerical_precision] [bool conviction_of_removal] [* output_sorted_list] || When used as a query argument, computes the case conviction for every case given in case_ids_to_compute with respect to *all* cases in the contained entities set input during a query.  If case_ids_to_compute is null/emptylist, case conviction is computed for all cases.  feature_labels specifies the names of the features to consider the during computation. p_value is the generalized norm parameter.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  \nFor attributes, the particular distance_types specifies what particular attributes are expected.  In all cases, there is the option to specify a list of values, where the second last value is the difference to use when one of the values being compared is null, and the last value is the difference to use when both of the values are null.  If the last value is omitted, it will use the second last value for both.  If both of the null values are omitted, then it will compute the maximum difference and use that for both.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values given.  Cyclic requires a single value, which is the upper bound of the difference for the cycle range (e.g., if the value is 360, then the supremum difference between two values will be 360, leading 1 and 359 to have a difference of 2).\n  Deviations contains numbers that are used during the distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0.  entities_returned specifies the number of entities to return. The optional radius_label parameter represents the label name of the radius of the entity (if the radius is within the distance, the entity is selected). The optional numerical_precision represents one of three values: \"precise\", which computes every distance with high numerical precision, \"fast\", which computes every distance with lower but faster numerical precison, and \"recompute_precise\", which computes distances quickly with lower precision but then recomputes any distance values that will be returned with higher precision.  If called last with compute_on_contained_entities, then it returns an assoc of the entity ids with their convictions.  A transform will be applied to these distances based on distance_transform.  If distance_transform is \"surprisal_to_prob\" then distances will be assumed to be surprisals and will be transformed back into probabilities for aggregating, and then transformed back to surprisals.  If distance_transform is a number or omitted, which will default to 1.0, then it will be used as a parameter for a generalized mean (e.g., -1 yields the harmonic mean) to average the distances.  If entity_weight_label_name is specified, it will multiply the resulting value for each entity (after distance_weight_exponent, etc. have been applied) by the value in the label of entity_weight_label_name. If conviction_of_removal is true, then it will compute the conviction as if the entities specified by entity_ids_to_compute were removed; if false (the default), then will compute the conviction as if those entities were added or included. If output_sorted_list is not specified or is false, then it will return an assoc of entity string id as the key with the distance as the value; if output_sorted_list is true, then it will return a list of lists, where the first list is the entity ids and the second list contains the corresponding distances, where both lists are in sorted order starting with the closest or most important (based on whether distance_weight_exponent is positive or negative respectively).  If output_sorted_list is a string, then it will additionally return a list where the values correspond to the values for each respective entity."
    },
    "(compute_entity_group_kl_divergence": {
        "prefix": "(compute_entity_group_kl_divergence",
        "body": [
            "(compute_entity_group_kl_divergence"
        ],
        "description": "compute_entity_group_kl_divergence number entities_returned list feature_labels list entity_ids_to_compute list|assoc weights list|assoc distance_types list|assoc attributes list|assoc deviations [number p_value] [string|number distance_transform] [string entity_weight_label_name] [number random_seed] [string radius_label] [string numerical_precision] [bool conviction_of_removal] || When used as a query argument, computes the case kl divergence for every case given in case_ids_to_compute as a group with respect to *all* cases in the contained entities set input during a query.  If case_ids_to_compute is null/emptylist, case conviction is computed for all cases.  feature_labels specifies the names of the features to consider the during computation. p_value is the generalized norm parameter.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  \nFor attributes, the particular distance_types specifies what particular attributes are expected.  In all cases, there is the option to specify a list of values, where the second last value is the difference to use when one of the values being compared is null, and the last value is the difference to use when both of the values are null.  If the last value is omitted, it will use the second last value for both.  If both of the null values are omitted, then it will compute the maximum difference and use that for both.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values given.  Cyclic requires a single value, which is the upper bound of the difference for the cycle range (e.g., if the value is 360, then the supremum difference between two values will be 360, leading 1 and 359 to have a difference of 2).\n  Deviations contains numbers that are used during the distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0.  entities_returned specifies the number of entities to return. The optional radius_label parameter represents the label name of the radius of the entity (if the radius is within the distance, the entity is selected). The optional numerical_precision represents one of three values: \"precise\", which computes every distance with high numerical precision, \"fast\", which computes every distance with lower but faster numerical precison, and \"recompute_precise\", which computes distances quickly with lower precision but then recomputes any distance values that will be returned with higher precision.  If called last with compute_on_contained_entities, then it returns an assoc of the entity ids with their convictions.  A transform will be applied to these distances based on distance_transform.  If distance_transform is \"surprisal_to_prob\" then distances will be assumed to be surprisals and will be transformed back into probabilities for aggregating, and then transformed back to surprisals.  If distance_transform is a number or omitted, which will default to 1.0, then it will be used as a parameter for a generalized mean (e.g., -1 yields the harmonic mean) to average the distances.  If entity_weight_label_name is specified, it will multiply the resulting value for each entity (after distance_weight_exponent, etc. have been applied) by the value in the label of entity_weight_label_name. If conviction_of_removal is true, then it will compute the conviction as if the entities specified by entity_ids_to_compute were removed; if false (the default), then will compute the conviction as if those entities were added or included."
    },
    "(compute_entity_distance_contributions": {
        "prefix": "(compute_entity_distance_contributions",
        "body": [
            "(compute_entity_distance_contributions"
        ],
        "description": "compute_entity_distance_contributions number entities_returned list feature_labels list entity_ids_to_compute list|assoc weights list|assoc list|assoc distance_types list|assoc attributes list|assoc deviations [number p_value] [string|number distance_transform] [string entity_weight_label_name] [number random_seed] [string radius_label] [string numerical_precision] [* output_sorted_list] || When used as a query argument, computes the case conviction for every case given in case_ids_to_compute with respect to *all* cases in the contained entities set input during a query.  If case_ids_to_compute is null/emptylist, case conviction is computed for all cases.  feature_labels specifies the names of the features to consider the during computation. p_value is the generalized norm parameter.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  \nFor attributes, the particular distance_types specifies what particular attributes are expected.  In all cases, there is the option to specify a list of values, where the second last value is the difference to use when one of the values being compared is null, and the last value is the difference to use when both of the values are null.  If the last value is omitted, it will use the second last value for both.  If both of the null values are omitted, then it will compute the maximum difference and use that for both.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values given.  Cyclic requires a single value, which is the upper bound of the difference for the cycle range (e.g., if the value is 360, then the supremum difference between two values will be 360, leading 1 and 359 to have a difference of 2).\n  Deviations contains numbers that are used during the distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0.  entities_returned specifies the number of entities to return. The optional radius_label parameter represents the label name of the radius of the entity (if the radius is within the distance, the entity is selected). The optional numerical_precision represents one of three values: \"precise\", which computes every distance with high numerical precision, \"fast\", which computes every distance with lower but faster numerical precison, and \"recompute_precise\", which computes distances quickly with lower precision but then recomputes any distance values that will be returned with higher precision.  If called last with compute_on_contained_entities, then it returns an assoc of the entity ids with their convictions.  A transform will be applied to these distances based on distance_transform.  If distance_transform is \"surprisal_to_prob\" then distances will be assumed to be surprisals and will be transformed back into probabilities for aggregating, and then transformed back to surprisals.  If distance_transform is a number or omitted, which will default to 1.0, then it will be used as a parameter for a generalized mean (e.g., -1 yields the harmonic mean) to average the distances.  If entity_weight_label_name is specified, it will multiply the resulting value for each entity (after distance_weight_exponent, etc. have been applied) by the value in the label of entity_weight_label_name. If output_sorted_list is not specified or is false, then it will return an assoc of entity string id as the key with the distance as the value; if output_sorted_list is true, then it will return a list of lists, where the first list is the entity ids and the second list contains the corresponding distances, where both lists are in sorted order starting with the closest or most important (based on whether distance_weight_exponent is positive or negative respectively).  If output_sorted_list is a string, then it will additionally return a list where the values correspond to the values for each respective entity."
    },
    "(compute_entity_kl_divergences": {
        "prefix": "(compute_entity_kl_divergences",
        "body": [
            "(compute_entity_kl_divergences"
        ],
        "description": "compute_entity_kl_divergences number entities_returned list feature_labels list entity_ids_to_compute list|assoc weights list|assoc distance_types list|assoc attributes list|assoc deviations [number p_value] [string|number distance_transform] [string entity_weight_label_name] [number random_seed] [string radius_label] [string numerical_precision] [bool conviction_of_removal] [* output_sorted_list] || When used as a query argument, computes the case conviction for every case given in case_ids_to_compute with respect to *all* cases in the contained entities set input during a query.  If case_ids_to_compute is null/emptylist, case conviction is computed for all cases.  feature_labels specifies the names of the features to consider the during computation. p_value is the generalized norm parameter.  If weights is null, then it will assume that the weights are 1 and additionally will ignore null values for the vectors instead of treating them as unknown differences.  The parameter distance_types is either a list strings or an assoc of strings indicating the type of distance for each feature.  Allowed values are \"nominal\" (checks for exact matches), \"continuous\" (takes the numeric difference between two values), \"cyclic\" (takes the numeric difference where the min and max wrap around), \"string\" (computes the edit distance between strings), and \"code\" (computes the edit distance between trees or graphs of code).  \nFor attributes, the particular distance_types specifies what particular attributes are expected.  In all cases, there is the option to specify a list of values, where the second last value is the difference to use when one of the values being compared is null, and the last value is the difference to use when both of the values are null.  If the last value is omitted, it will use the second last value for both.  If both of the null values are omitted, then it will compute the maximum difference and use that for both.  For a nominal distance_type, a number indicates the nominal count, whereas null will infer from the values given.  Cyclic requires a single value, which is the upper bound of the difference for the cycle range (e.g., if the value is 360, then the supremum difference between two values will be 360, leading 1 and 359 to have a difference of 2).\n  Deviations contains numbers that are used during the distance calculation, per-element, prior to exponentiation.  Specifying null as deviations is equivalent to setting each deviation to 0.  entities_returned specifies the number of entities to return. The optional radius_label parameter represents the label name of the radius of the entity (if the radius is within the distance, the entity is selected). The optional numerical_precision represents one of three values: \"precise\", which computes every distance with high numerical precision, \"fast\", which computes every distance with lower but faster numerical precison, and \"recompute_precise\", which computes distances quickly with lower precision but then recomputes any distance values that will be returned with higher precision.  If called last with compute_on_contained_entities, then it returns an assoc of the entity ids with their convictions.  A transform will be applied to these distances based on distance_transform.  If distance_transform is \"surprisal_to_prob\" then distances will be assumed to be surprisals and will be transformed back into probabilities for aggregating, and then transformed back to surprisals.  If distance_transform is a number or omitted, which will default to 1.0, then it will be used as a parameter for a generalized mean (e.g., -1 yields the harmonic mean) to average the distances.  If entity_weight_label_name is specified, it will multiply the resulting value for each entity (after distance_weight_exponent, etc. have been applied) by the value in the label of entity_weight_label_name. If conviction_of_removal is true, then it will compute the conviction as if the entities specified by entity_ids_to_compute were removed; if false (the default), then will compute the conviction as if those entities were added or included. If output_sorted_list is not specified or is false, then it will return an assoc of entity string id as the key with the distance as the value; if output_sorted_list is true, then it will return a list of lists, where the first list is the entity ids and the second list contains the corresponding distances, where both lists are in sorted order starting with the closest or most important (based on whether distance_weight_exponent is positive or negative respectively).  If output_sorted_list is a string, then it will additionally return a list where the values correspond to the values for each respective entity."
    },
    "(contains_label": {
        "prefix": "(contains_label",
        "body": [
            "(contains_label"
        ],
        "description": "contains_label [id entity] string label_name || Evaluates to true if the label represented by string exists for the entity specified by id for a contained entity.  If id is omitted, then it uses the current entity."
    },
    "(assign_to_entities": {
        "prefix": "(assign_to_entities",
        "body": [
            "(assign_to_entities"
        ],
        "description": "assign_to_entities [id entity_1] assoc variable_value_pairs_1 [id entity_2] [assoc variable_value_pairs_2] [...] || For each index-value pair of variable_value_pairs, assigns the value to the labeled variable on the contained entity represented by the respective entity, itself if no id specified, while retaining the original labels. If none found, it will not cause an assignment. When the value is assigned, any labels will be cleared out and the root of the value will be assigned the comments and labels of the previous root at the label. Will perform an assignment for each of the entities referenced, returning (true) if all assignments were successful, (false) if not."
    },
    "(accum_to_entities": {
        "prefix": "(accum_to_entities",
        "body": [
            "(accum_to_entities"
        ],
        "description": "accum_to_entities [id entity_1] assoc variable_value_pairs_1 [id entity_2] [assoc variable_value_pairs_2] [...] || For each index-value pair of assoc, retrieves the labeled variable from the respective entity, accumulates it by the corresponding value in variable_value_pairs, then assigns the value to the labeled variable on the contained entity represented by the id, itself if no id specified, while retaining the original labels. If none found, it will not cause an assignment. When the value is assigned, any labels will be cleared out and the root of the value will be assigned the comments and labels of the previous root at the label.  Accumulation is performed differently based on the type: for numeric values it adds, for strings, it concatenates, for lists it appends, and for assocs it appends based on the pair. Will perform an accum for each of the entities referenced, returning (true) if all assignments were successful, (false) if not."
    },
    "(direct_assign_to_entities": {
        "prefix": "(direct_assign_to_entities",
        "body": [
            "(direct_assign_to_entities"
        ],
        "description": "direct_assign_to_entities [id entity_1] assoc variable_value_pairs_1 [id entity_2] [assoc variable_value_pairs_2] [...] || Like assign_to_entities, except retains any/all labels, comments, etc."
    },
    "(retrieve_from_entity": {
        "prefix": "(retrieve_from_entity",
        "body": [
            "(retrieve_from_entity"
        ],
        "description": "retrieve_from_entity [id entity] [string|list|assoc label_names] || If string specified, returns the value of the contained entity id, itself if no id specified, at the label specified by the string. If list specified, returns the value of the contained entity id, itself if no id specified, returns a list of the values on the stack specified by each element of the list interpreted as a string label. If assoc specified, returns the value of the contained entity id, itself if no id specified, returns an assoc with the indices of the assoc passed in with the values being the appropriate values of the label represented by each index."
    },
    "(direct_retrieve_from_entity": {
        "prefix": "(direct_retrieve_from_entity",
        "body": [
            "(direct_retrieve_from_entity"
        ],
        "description": "direct_retrieve_from_entity [id entity] [string|list|assoc label_names] || Like retrieve_from_entity, except retains labels."
    },
    "(call_entity": {
        "prefix": "(call_entity",
        "body": [
            "(call_entity"
        ],
        "description": "call_entity id entity [string label_name] [assoc arguments] [number operation_limit] [number max_node_allocations] || Calls the contained entity specified by id, using the entity as the new entity context.  It will evaluate to the return value of the call, null if not found.  If string is specified, then it will call the label specified by string.  If assoc is specified, then it will pass assoc as the arguments on the scope stack.  If operation_limit is specified, it represents the number of operations that are allowed to be performed. If operation_limit is 0 or infinite, then an infinite of operations will be allotted to the entity, but only if its containing entity (the current entity) has infinite operations. The root entity has infinite computing cycles.  If max_node_allocations is specified, it represents the maximum number of nodes that are allowed to be allocated, limiting the total memory.   If max_node_allocations is 0 or infinite, then there is no limit to the number of nodes to be allotted to the entity as long as the machine has sufficient memory, but only if the containing entity (the current entity) has unlimited memory access.  The execution performed will use a random number stream created from the entity's random number stream."
    },
    "(call_entity_get_changes": {
        "prefix": "(call_entity_get_changes",
        "body": [
            "(call_entity_get_changes"
        ],
        "description": "call_entity_get_changes id entity [string label_name] [assoc arguments] [number operation_limit] [number max_node_allocations] || Like call_entity returning the value in *1.  However, it also returns a list of direct_assign_to_entities calls with respective data in *2, holding a log of all of the changes that have elapsed.  The log may be evaluated to apply or re-apply the changes to any id passed in to the log as _."
    },
    "(call_container": {
        "prefix": "(call_container",
        "body": [
            "(call_container"
        ],
        "description": "call_container string parent_label_name [assoc arguments] [number operation_limit] [number max_node_allocations] || Attempts to call the container associated with the label specified by string prepended by a caret (^); the caret indicates that the label is allowed to be accessed by contained entities.  It will evaluate to the return value of the call, null if not found.  The call is made on the label specified by string.  If assoc is specified, then it will pass assoc as the arguments on the scope stack.  The parameter accessing_entity will automatically be set to the id of the caller, regardless of the arguments.  If operation_limit is specified, it represents the number of operations that are allowed to be performed. If operation_limit is 0 or infinite, then an infinite of operations will be allotted to the entity, but only if its containing entity (the current entity) has infinite operations. The root entity has infinite computing cycles.  If max_node_allocations is specified, it represents the maximum number of nodes that are allowed to be allocated, limiting the total memory.   If max_node_allocations is 0 or infinite, then there is no limit to the number of nodes to be allotted to the entity as long as the machine has sufficient memory, but only if the containing entity (the current entity) has unlimited memory access.  The execution performed will use a random number stream created from the entity's random number stream."
    }
}